"""
Categories of algorithms:

* Simple recursive algorithm - Solves the base case directly and then recurs with a simpler or easier input every time (A base value is set at the starting for which the algorithm terminates).

* Divide and conquer - Breaks a problem into smaller simple sub-problems, and then solving these sub-problems, and finally, combining the results to obtain a global optimal solution.

Some examples of divide and conquer algorithm paradigms are as follows:
    • Binary search
    • Merge sort
    • Quick sort
    • Karatsuba algorithm for fast multiplication
    • Strassen's matrix multiplication
    • Closest pair of points

* Greedy algorithms - Greedy algorithms often involve optimization and combinatorial (relating to the selection of a given number of elements from a larger number without regard to their arrangement) problems.

The classic example is to apply the greedy algorithm to the traveling salesperson problem, where a greedy approach always chooses the closest destination first. This shortest-path strategy involves finding
the best solution to a local problem in the hope that this will lead to a global solution. In this way, we are not sure that we get the best solution, but we surely get an optimal solution.

Here are many popular standard problems where we can use greedy algorithms to obtain the optimum solution:
    • Kruskal's minimum spanning tree
    • Dijkstra's shortest path
    • Knapsack problem
    • Prim's minimal spanning tree algorithm
    • Travelling salesman problem

* Dynamic programming - A dynamic programming algorithm (also known as dynamic optimization algorithm) remembers the past result and uses them to find new result means it solve complex problems by breaking it
down into a collection of simpler subproblems, then solving each of those subproblems only once ,and storing their solution for future use instead of recomputing their solutions again.

"""